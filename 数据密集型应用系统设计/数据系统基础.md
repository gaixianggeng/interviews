# 数据密集型应用系统设计

# 数据系统基础

### 数据密集型应用系统原则

- 数据密集型
- 计算密集型

### 系统模块

- 数据库
- 高速缓存
- 索引
- 流式处理
- 批处理

## P1. 可靠、可扩展和可维护的应用系统

- 可靠性
  - 容错针对特定类型的故障才更有实际意义。
  - 多机冗余对于一些关键应用，保证其高可用绝对是有必要的。
  - 软件容错作为硬件容错的补充
  - 假设人是不可靠的
  - 测试环境以及测试用例
  - 发布系统 及时回滚
  - 监控系统
- 可扩展性
  - 描述负载
  - 描述性能
  - 扇出结构
  - 拆分读写性能
  - 垂直扩展 水平扩展 针对有状态服务和无状态服务区分
    - 将数据库运行在一个节点（垂直扩展策略） 直接高扩展性和高可用性的要求破事不得不做水平扩展
    - 超大规模的系统往往针对特定应用而高度定制
- 可维护性
  - 可维护性 监控、自动化、服务发现等
  - 简化复杂度
    - 模块紧耦合
    - 相互依赖
    - 不一致的命名和术语
    - 为了性能or需求做特殊处理
    - 解决特定问题引入特殊框架
    - …
  - 抽象
  - 可演化性：数据系统级的敏捷性

## P2. 数据模型与查询语言

- 复杂的应用程序有更多的中间层，每层都通过提供一个简洁的数据模型来隐藏下层的复杂性

### 关系模型

- 目标是将实现细节隐藏在简洁的接口下面
- 使用id的好处，他对人类没有任何直接意义
- 定义了所有数据的格式
- 具体的查询逻辑由查询优化器自动生成，不是由开发人员维护
- 关系模型的核心：只需要构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益

### 文档模型

- 一对多的树状结构不需要联接，对联结的支持很弱
- 联结的工作从数据层转移到了应用层

### 对比

- 支持文档数据模型的主要论点是模式灵活性，由于局部性而带来较好的性能，对于某
些应用来说，它更接近于应用程序所使用的数据结构。
- 关系模型则强在联结操作，多对一和多对多关系更简洁的表达上，与文档模型抗衡。

### 声明式查询语言

- SQL
- 只需要指定所需的数据模型，不需要指明如何实现这一目标
- 适合并行执行

### 命令式查询语言

- 告诉计算机以特定的顺序执行某些操作

### MapReduce查询

- map和reduce西数对于可执行的操作有所限制。它们必须是純函数，这意味着只能使
用传递进去的数据作为输人，而不能执行额外的数据库查询，也不能有任何副作用。
这些限制使得数据库能够在任何位置、以任意顺序来运行函数，并在失败时重新运行
这些函数。不管怎样，该功能非常强大，可以通过它来解析字符串、调用库函数、执
行计算等。
- MapReduce是一个相当底层的编程模型，用王在让算集群上分布执行。而SQL这样的
更高层次的查询语言可以通过一些MapReduce操作pipeline来实现

## P3.数据存储与检索

- 数据库只需要做两件事，向它插入数据是，它就保存数据；查询时返回那些数据
- OLTP 在线事务处理
- OLAP 在线分析处理

### 数据结构（数据库的核心）

- 日志机制
- 索引

    基于原始数据派生而来的额外数据结构。

    很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。

    维护额外的结构势必会引入开销，任何类型的索引通常都会降低写的速度

    适当的索引可以加速读取查询，但每个索引都会减慢写速度。为此，默认情况下，数据库通常不会对所有内容进行索引

    **哈希索引**

    Kex-value类型并不是唯一可以索引的数据，但它随处可见，而且是其他更复杂索引的基础构造模块

    局限性：必须全部放入内存；区间查询效率不高

### 段

段在写入后不会进行修改，合并的段会被写入一个新文件，每个段都有自己的内存哈希表

- 为什么不原地更新，新值覆盖旧值，而是追加？

    追加和分段合并主要是顺序写，它通常比随机写入快得多，特别是在旋转式磁
    性硬盘上。在某种程度上，顺序写入在基于闪存的固态硬盘 (solid state drives,
    SSD）上也是适合的。

    如果段文件是追加的或不可变的，则并发和崩溃恢复要简单得多。例如，不必担
    心在重写值时发生崩溃的情况，留下一个包含部分旧值和部分新值混杂在一起的
    文件。
    合并旧段可以避免随着时间的推移数据文件出现碎片化的问题。

### SSTable和LSM-Tree

- 合并段更加高效，多路合并
- 查找特定键更高效，不需要内存保存全部的键，可以稀疏

存储引擎的工作流程

- 类似lucene写入 略

### B-Trees

### 对比B-Tree和LSM_Tree

- p84

### 事务处理和分析处理

- LOLTP和OLAP
- 列式存储
  - 非常适合压缩 列压缩

### 总结

- p101

## P4. 数据编码和演化

- 新旧数据兼容问题

### 两种不同的数据表现形式

- 在**内存**中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些
数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）
- 将**数据写入文件或通过网络发送**时：必须将其编码为某种自包含的字节序列（例
如JSON文档）。由于指针对其他进程没有意义，所以这个字节序列表示看起来
与内在中使用的数据结构大不一样

### 模式的优点

- p124

### REST和RPC的对比，优劣

- p127

# 分布式系统

- 扩展性
- 容错与高可用性
- 延迟考虑
- 系统扩展能力
  - 无共享架构（水平扩展）
  - 复制 多个节点保存相同的数据副本
  - 分区 将一大块数据拆分为多个较小的子集即分区（分片）

## 数据复制
### 目的
* 地理位置接近 降低访问延迟
* 部分故障依旧可用，提高可用性
* 多台提供服务 提高吞吐量

针对持续更改的数据
复制数据的方法：主从复制、多主节点复制、无主节点复制

### 主从复制的工作原理
* p146
**同步复制 异步复制**
* p148
* 半同步
**配置新的从节点**
* p149

** 处理失效节点 ** 

### 复制日志
## 数据分区

## 事务

### 隔离级别

读提交、快照隔离（或可重复读取） 当可串行化。通过分析如何处理边界条件求来阐述这些隔离级别的要点．

### 脏读

客户端读到了其他客户端尚未提交的写人。读-提交以及更强的隔离级别可以防止脏读。

### 脏写

客户端覆盖了另一个客户端尚未提交的写入。几乎所有的数据库实现都可以防止脏写

### 读倾斜 （不可重复读)

客户在不同的时间点看到了不同值。快照隔离是最有用的防范手段，即事务总是在某个时间点的一致性快照中读取数据。通常采用多版本并发控制(MVCC)来实现快照隔离。

### 更新丢失

两个客户端同时执行读-修改-写入操作序列，出现了其中一个覆盖了另一个的写入，但又没有包含对方最新值的情况，最终导致了部分修改数据发生了丟失。快照隔离的一些实现可以自动防止这种异常，而另一些则需要手动锁定查询结果(SELECT FOR UPDATE)

### 写倾斜

事务首先查询数据，根据返回的结果而作出某些决定，然后修改数据库。当事务提交时，支持决定的前提条件已不再成立。只有可串行化的隔离才能防止这种异常

### 幻读

事务读取了某些符合查询条件的对象，同时另一个客户端执行写入，改变了先前的查询结果。快照隔离可以防止简单的幻读，但写倾斜情况则需要特殊处理，例如采用区间范围锁

弱隔离级别可以防止上面的某些异常，但还需要应用开发人员手动处理其他复杂情况（例如，显式加锁）。只有可串行化的隔离可以防止所有这些问题。我们主要讨论了实现可串行化隔离的三种不同方法：

- 严格串行执行事务
  如果每个事务的执行速度非常快，且单个CPU核可以满足事务的吞吐量要求，严格串行执行是一个非常简单有效的方案。
- 两阶段加锁
几十年来，这一直是实现可串行化的标谁方式，但还是有很多系统出于性能原因而放弃使用它。
- 可串行化的快照隔离 (SSI)
一种最新的算法，可以避免前面方法的大部分缺点。它秉持乐观预期的原则，允许多个事务并发执行而不互相阻塞：仅当事务尝试提交时，才检查可能的冲突，如果发现违背了串行化，则某些事务会被中止。

## 分布式系统的挑战

## 一致性与共识

- 线性化

- 因果关系
- 共识问题
- 全序广播

# 异构系统的派生数据

## 批处理系统

## 流处理系统

## 数据系统的未来
