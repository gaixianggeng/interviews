# 数据密集型应用系统设计

# 数据系统基础

### 数据密集型应用系统原则

- 数据密集型
- 计算密集型

### 系统模块

- 数据库
- 高速缓存
- 索引
- 流式处理
- 批处理

## P1. 可靠、可扩展和可维护的应用系统

- 可靠性
    - 容错针对特定类型的故障才更有实际意义。
    - 多机冗余对于一些关键应用，保证其高可用绝对是有必要的。
    - 软件容错作为硬件容错的补充
    - 假设人是不可靠的
    - 测试环境以及测试用例
    - 发布系统 及时回滚
    - 监控系统
- 可扩展性
    - 描述负载
    - 描述性能
    - 扇出结构
    - 拆分读写性能
    - 垂直扩展 水平扩展 针对有状态服务和无状态服务区分
        - 将数据库运行在一个节点（垂直扩展策略） 直接高扩展性和高可用性的要求破事不得不做水平扩展
        - 超大规模的系统往往针对特定应用而高度定制
- 可维护性
    - 可维护性 监控、自动化、服务发现等
    - 简化复杂度
        - 模块紧耦合
        - 相互依赖
        - 不一致的命名和术语
        - 为了性能or需求做特殊处理
        - 解决特定问题引入特殊框架
        - …
    - 抽象
    - 可演化性：数据系统级的敏捷性

## P2. 数据模型与查询语言

- 复杂的应用程序有更多的中间层，每层都通过提供一个简洁的数据模型来隐藏下层的复杂性

### 关系模型

- 目标是将实现细节隐藏在简洁的接口下面
- 使用id的好处，他对人类没有任何直接意义
- 定义了所有数据的格式
- 具体的查询逻辑由查询优化器自动生成，不是由开发人员维护
- 关系模型的核心：只需要构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益

### 文档模型

- 一对多的树状结构不需要联接，对联结的支持很弱
- 联结的工作从数据层转移到了应用层

### 对比

- 支持文档数据模型的主要论点是模式灵活性，由于局部性而带来较好的性能，对于某
些应用来说，它更接近于应用程序所使用的数据结构。
- 关系模型则强在联结操作，多对一和多对多关系更简洁的表达上，与文档模型抗衡。

### 声明式查询语言

- SQL
- 只需要指定所需的数据模型，不需要指明如何实现这一目标
- 适合并行执行

### 命令式查询语言

- 告诉计算机以特定的顺序执行某些操作

### MapReduce查询

- map和reduce西数对于可执行的操作有所限制。它们必须是純函数，这意味着只能使
用传递进去的数据作为输人，而不能执行额外的数据库查询，也不能有任何副作用。
这些限制使得数据库能够在任何位置、以任意顺序来运行函数，并在失败时重新运行
这些函数。不管怎样，该功能非常强大，可以通过它来解析字符串、调用库函数、执
行计算等。
- MapReduce是一个相当底层的编程模型，用王在让算集群上分布执行。而SQL这样的
更高层次的查询语言可以通过一些MapReduce操作pipeline来实现

## P3.数据存储与检索

- 数据库只需要做两件事，向它插入数据是，它就保存数据；查询时返回那些数据
- OLTP 在线事务处理
- OLAP 在线分析处理

### 数据结构（数据库的核心）

- 日志机制
- 索引
    
    基于原始数据派生而来的额外数据结构。
    
    很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。
    
    维护额外的结构势必会引入开销，任何类型的索引通常都会降低写的速度
    
    适当的索引可以加速读取查询，但每个索引都会减慢写速度。为此，默认情况下，数据库通常不会对所有内容进行索引
    
    **哈希索引**
    
    Kex-value类型并不是唯一可以索引的数据，但它随处可见，而且是其他更复杂索引的基础构造模块
    
    局限性：必须全部放入内存；区间查询效率不高
    

### 段

段在写入后不会进行修改，合并的段会被写入一个新文件，每个段都有自己的内存哈希表

- 为什么不原地更新，新值覆盖旧值，而是追加？
    
    追加和分段合并主要是顺序写，它通常比随机写入快得多，特别是在旋转式磁
    性硬盘上。在某种程度上，顺序写入在基于闪存的固态硬盘 (solid state drives,
    SSD）上也是适合的。
    
    如果段文件是追加的或不可变的，则并发和崩溃恢复要简单得多。例如，不必担
    心在重写值时发生崩溃的情况，留下一个包含部分旧值和部分新值混杂在一起的
    文件。
    合并旧段可以避免随着时间的推移数据文件出现碎片化的问题。
    

### SSTable和LSM-Tree

- 合并段更加高效，多路合并
- 查找特定键更高效，不需要内存保存全部的键，可以稀疏

存储引擎的工作流程

- 类似lucene写入 略

### B-Trees

### 对比B-Tree和LSM_Tree

- p84

### 事务处理和分析处理

- LOLTP和OLAP
- 列式存储
    - 非常适合压缩 列压缩

### 总结

- p101

## P4. 数据编码和演化

- 新旧数据兼容问题

### 两种不同的数据表现形式

- 在**内存**中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些
数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）
- 将**数据写入文件或通过网络发送**时：必须将其编码为某种自包含的字节序列（例
如JSON文档）。由于指针对其他进程没有意义，所以这个字节序列表示看起来
与内在中使用的数据结构大不一样

### 模式的优点

- p124

### REST和RPC的对比，优劣

- p127

# 分布式系统
## 数据复制

## 数据分区
## 事务

## 分布式系统的挑战

## 一致性与共识

# 异构系统的派生数据

## 批处理系统

## 流处理系统

## 数据系统的未来