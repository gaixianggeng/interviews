# 内存管理

## 内存分配

### 概述
* 内存分配器类似tcmalloc的方式
* 维护一大块全局内存，每个线程都维护一块私有内存
* 根据size计算合适的classid（67种）
* 优先线程缓存，然后中心缓存，最后从mheap中申请

### 基本概念
* 内存管理单元 runtime.mspan
* page大小为8k
* arena 区域是真正的堆区
* spans 区域存储了指向runtime.mspan的指针

### 分配方法
* 线性分配（顺序分配）
* 空闲链表分配

### 分级分配
![多级缓存内存分配](https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png)
* 页堆
* 线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存
* runtime.spanClass 跨度类 内存管理单元中存储的对象大小和个数 67种
* runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。
* runtime.mcentral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁
* runtime.mheap 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段
* 微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；
* 小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；
* 大对象 (32KB, +∞) — 直接在堆上分配内存；
* 微分配器管理的对象不可以是指针类型

### 归还内存
* 主动策略 每五分钟
* 1.16使用donotneed参数告知操作系统进行回收


### 为什么要内存管理
* 减少与操作系统沟通造成的开销
* 更好的支持垃圾回收

### go语言的堆栈和传统上的堆栈的区别
* 传统意义上的栈被go运行时占用，不会开放给用户态代码
* 传统的堆被分为两部分
  * 堆外内存，即运行时需要的堆内存
  * 用户态代码需要的堆内存 Go堆，负责goroutine的执行栈

## 垃圾回收

> 内存分配器在堆中申请内存，垃圾收集器负责回收堆中的内存空间
### 标记清除
* 标记阶段 从根对象出发，查找并标记堆中所有存活的对象
* 清除阶段 遍历堆中的全部对象，回收未必标记的垃圾对象，并将回收的内存加入空闲链表

### 三色标记
> 原始标记清楚算法会带来长时间的stw
* 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收
* 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象
* 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象
### 垃圾回收流程
三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：
* 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
* 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
* 重复上述两个步骤直到对象图中不存在灰色对象；

当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾

### 屏障技术
> 本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性5，想要并发或者增量地标记对象还是需要使用屏障技术
* 该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作
* 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
* 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径
* 插入写屏障 保证强三色不变性
* 删除写屏障 保证弱三色不变性
* 增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；
* 并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；

### 垃圾回收器
划分为两个半独立的组件
* 赋值器 指代用户态的代码，修改对象之间的引用关系
* 回收器 负责执行回收的代码

### 根对象是什么
* 全局变量
* 每个goroutine的执行栈
* 寄存器
### 常见的垃圾回收方式
* 追踪 标记清除 分代
* 引用计数

### 什么是STW
* 在垃圾回收过程中，为了保证实现的正确性，防止无止境的内存增长而不可避免的需要停止赋值器进一步操作对象的一段过程，称为STW（Stop the world）

### 如何观察垃圾回收过程
* gctrace=1
* go tool trach
  
### 有了垃圾回收为什么会发生内存泄漏
> 预期能很快被释放的内存由于附着在了长期存活的内存上或者生命期意外的被延长
* 预期能快速释放的内存因被根对象引用而没有得到释放
* goroutine泄漏

### 并发标记清除的难点
* 用户态代码在回收过程中会并发的修改更新对象图

### 什么是写屏障 混合写屏障
> 垃圾回收的正确性体现在不应出现丢失的对象，也不应错误的回收还不需要回收的对象
* 混合插入写屏障和删除写屏障，对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，同样对指针进行着色

* 批量写屏障机制：对需要着色的指针统一写入缓存，缓存满时统一对ptr指针进行着色

### 垃圾回收的流程

### 触发垃圾回收的时机

### 内存分配速度超过了标记清楚的速度怎么办