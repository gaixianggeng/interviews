# 精通区块链编程

## 比特币介绍

比特币既是构成数字货币生态系统基础概念和技术的总称，又是比特币网络参与者存储和传输的货币单位
比特币是分布式的点对点的系统，比特币是通过挖矿的流程创造出来的
挖矿流程涉及在打包处理比特币交易过程中矿工竞争式的寻找一个数学问题的解（寻找符合条件的hash值）
比特币挖矿流程代替了中央银行的货币发行和结算功能，通过分布式架构取代中央银行的地位
比特币总数限制在2100w以内

### 比特币的创新

- 去中心化的点对点网络（比特币协议）
- 一本公开的交易总账
- 一套可独立校验交易和发行货币的规则（共识规则）
- 一种通过全球去中心化对有效的区块链达成共识的机制（工作量证明算法）

最关键的创新是使用分布式计算系统（工作量证明算法）每十分钟进行一次全球性质的“选举”，从而让分布式网络达成关于已经发生交易状态的共识

### 比特币钱包

- 比特币系统常见的用户界面
- 常见的三种钱包：桌面全节点客户端、手机轻量级钱包、网络第三发钱包

私钥

比特币地址

比特币交易是不可撤销的

## 比特币工作原理

交易、区块、挖矿和区块链

**比特币系统**由用户、交易和矿工三方构成，用户使用包含秘钥的钱包、交易在整个网络传播、矿工则生产（通过竞争性计算）出共识性区块链，也就是所有交易的公共权威账本

**比特币交易** 一笔交易是告知全网这部分比特币持有者已经授权把它转给新的持有者，新的持有者可以创造新的交易花掉所持有的的比特币，而这笔交易又再次将比特币授权给另一位持有者，形成一条所有者的链表

许多比特币交易包含指向新的持有者的地址和现持有者的地址，被称作“找零”地址

钱包应用可以在离线时建立交易

比特币交易不需要连接比特币网络的时候建立和签署

一个运行**全节点客户端**的比特币钱包实际上包含整个区块链上每笔交易的未消费输出和副本，这使得一个钱包既能构建交易输入，又能基于正确的输入快速验证收到的新交易，然而全节点客户端会使用大量的硬盘空间，大多数用户**钱包**使用轻量级客户端，**只维护自己未消费的输出**。

**交易的输出**以脚本的形式被创建，它设置对兑换价值的保护，只能通过引导对这个脚本的解答才能兑换。

**交易费用**作为矿工检验交易、包括到一个区块并记录在区块链上的费用

**区块链网络**的目的是将交易和区块传播给所有参与者

传播：任何收到了之前没见过的有效交易的比特币节点，会立即向连在它之上的所有节点转发，这个传播技巧叫做**泛滥**。

**比特币挖矿** 通过挖矿的过程被检验并被包括到一个区块之中，才会成为区块链的一部分。

**打包过程需要大量计算来证明，检验仅需要很少的计算量**

挖矿的作用

- 挖矿节点通过参考比特币的共识规则**检验所有交易**，挖矿通过拒绝无效或者不正常的交易为比特币交易提供安全保证
- 挖矿在构建区块是会**创造新的比特币**，类似中央银行引发新纸币，每个区块创造的比特币的数量是有限的，并按照随着时间减少的固定发行规则。

挖矿在成本和汇报之间达成平衡，使用**电力解决数学问题**。矿工通过新的比特币和交易手续费获取回报，矿工只有按照共识规则正确验证所有交易之后才会获得回报，这种平衡在没有中央权威的情况下为比特币提供了安全保证。

**工作量证明算法**需要重复对区块的头和一个随机数使用sha256加密算法计算哈希值**直到出现预定匹配的解答**，第一个找到解答的矿工赢得这一轮，并将得到的区块发布到区块链上。

**挖掘交易**

新的交易流入网络，当被比特币网络节点看到时，便会被加到每个节点维护的未验证的临时池子，当打包新块时，会从临时的池子里选择未验证的交易加入新区块，使用工作量证明算法来证明新块的有效性

交易加入到区块，会按照**手续费和其他条件排序**，每个矿工从网络收到之前的区块时，便知道自己输掉了上一轮，开始新的挖掘，创建新的区块，填入交易和之前区块的指纹，进行下一轮。

区块一个叠一个，逆转交易的难度将指数级增加，从而让他变得更加被网络信任。

每个比特币客户端可独立验证交易是合法的和可消费的

## 核心客户端

[https://zh.wikipedia.org/wiki/對等網路](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF) p2p

比特币对等网络的节点主要由志愿者和一些构建比特币应用程序的商业机构运行，比特币节点具有直接和权威的比特币区块链视图并且拥有所有交易的副本

可以通过配置比特币核心通过丢弃旧块来减少区块链大小

比特币核心客户端实现了json-rpc接口

**交易id在交易未必确认前不具有权威性**

## 密钥和地址

比特币是基于密码学的

比特币的通信和交易数据并没有加密，也不需要通过加密来保护资金

比特币所有权是通过数字密钥、比特币地址和数字签名建立起来的，数字密钥不存储在网络中，由用户创建、存在钱包中，**数字密钥完全独立于比特币协议**，可以由钱包生成和管理，密钥使得比特币的去中心化的信任和控制、所有权认证和基于密码学的验证的安全模型得以实现

**任何人拥有了密钥副本就拥有了对该账户的比特币控制权**

用于支出资金的数字签名称为**见证**

**密钥是成对出现的，由私钥和公钥组成**，比特币地址由公钥生成并对应与这个公钥

不可逆的数学函数 单向加密函数 **椭圆曲线乘法**

密码对包含一个私钥和从它派生出来唯一的公钥，**公钥用于接收比特币，私钥用于为比特币支付进行交易签名**

公钥和私钥的数学关系：**允许私钥在消息上生成签名，签名可以在不泄露私钥的情况下通过公钥进行验证**

支付时，比特币所有者需要在交易中展示公钥和签名（每次签名都不同，均由同一个私钥创建），比特币网络对其验证是否有效，确认支付者对比特币的拥有权

**私钥k通常是一个随机选择的数字，基于私钥可以使用椭圆曲线乘法这个单向加密函数来生成一个公钥K，基于公钥K可以使用单向加密函数生成比特币地址A**

非对称加密？

对私钥的的所有权和控制权是用户对相应的比特币地址中所有资金的控制根源

**私钥在任何时候都需要保密，一旦丢失无法恢复**

熵源（随机性来源）

比特币使用**操作系统底层的随机数生成器**来产生256位的熵

通过椭圆曲线函数可以从私钥得到公钥，不可逆 K=k*G（生成点的常数点）k和K的关系是固定的，只能单向运算

比特币地址是由数字和字母组成的字符串，由公钥生成的比特币地址以数字1开头

**比特币地址由公钥经过单向的加密散列算法得到**，散列算法是一种单向函数，能够接受任意长度的输入值产生一个指纹或散列。

加密散列函数作为比特币地址、脚本地址以及挖矿的工作量证明算法

base58check编码，提高可读性和录入的正确性

base58是不包括0、O、1、I的大小写和+ / 的其他字母和数字组成

校验和checksum是添加到正在编码的数据末端的额外四个字节

前缀+数据+校验和 比特币地址以1开头，私钥wif以5开头

**私钥和公钥都可以以多种不同的格式呈现，虽然格式不同，但密钥所编码的数字没有改变**

私钥所有的格式都对应256位的数字

wif压缩格式的私钥以字母k、l开头

公钥分为非压缩格式公钥04和压缩格式公钥02偶数/03奇数

**将压缩的公钥引入比特币是为了减少交易大小，并为存储比特币区块链节点节省磁盘空间**

一个私钥可以生成两种不同格式的公钥（压缩、非压缩），这两种可以生成两种不同的比特币地址，但是私钥是同一个

**压缩格式私钥表示用于生成压缩格式公钥的私钥，多了后缀01，表明来自较新的钱包**

在实现了压缩格式公钥较新的钱包中，私钥只能被导出为wif压缩格式（k\l），较老的只能导出为wif格式5为前缀

加密私钥标准BIP-38 6P开头的base58check编码的加密私钥

**以数字3开头的比特币地址是P2SH（pay-to-script hash）地址**，有时被错误地称为多重签名或多重签名地址。它们指定比特币交易中受益人为一个脚本的散列，而不是公钥的所有者。不同于**P2PKH（pay-to-public-key-hash）**，交易会发送资金到传统的以1开头的比特币地址，资金被发送到以3开头的地址时，需要的不仅仅是一个公钥的散列值和一个私钥签名来作为所有者证明。在创建地址的时候，这些具体的要求会被指定在脚本中，这个地址的所有输入都将受到相同的要求。

**P2SH函数最常见的实现是多重签名地址脚本**。顾名思义，底层脚本需要多个签名来证明所有权，此后才能消费资金。设计比特币多重签名特性时需要从总共N个密钥中获得M个签名（也被称为“阈值”），被称为M-N多重签名，其中M等于或小于N

靓号地址

认识到比特币地址不过是由Base58字母代表的一个数字是非常重要的

**生成一个靓号地址是一项使用蛮力的过程**：尝试一个随机密钥，检查生成的地址是否和所需的样式相匹配，重复这个过程直到成功地找到靓号为止。

纸钱包是打印在纸张上的比特币私钥

## 钱包

广义上讲，**钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理私钥和地址，跟踪余额以及创建和签名交易**。狭义上讲，从程序员的角度来看，**“钱包”是指用于存储和管理用户私钥的数据结构。**

钱包只包含密钥。比特币被记录在比特币网络的区块链中。用户通过使用钱包中的密钥签署交易来控制网络上的比特币。从某种意义上说，**比特币钱包是一个钥匙扣**（keychain）。

**比特币以交易记录（通常记为vout或txout）的形式存储在区块链中**。

钱包分类

- 第一种类型是**非确定性钱包**（nondeterministic wallet），其中每个私钥都是从随机数独立生成的，密钥彼此之间无关联。这种钱包也称为简单钥匙串（Just aBunch Of Keys，一堆私钥的集合），简称**JBOK钱包**。
- 第二种类型是**确定性钱包**（deterministic wallet），其中所有的私钥都是从一个主私钥派生出来，这个主私钥即为种子（seed）。该类型钱包中所有私钥都相互关联，如果有原始种子，则可以再次生成全部私钥。确定性钱包有许多不同的密钥派生方法。最常用的派生方法是使用**树状结构，称为分层确定性钱包或HD钱包。**确定性钱包由种子派生出来的。为了便于使用，种子被编码为英文单词**，**也称为**助记词。**

非确定性钱包：钱包只是随机生成私钥的集合 难以管理、备份以及导入

确定性（种子）钱包：所包含的私钥都是通过使用单向散列（hash）函数从公共种子派生出来的。种子是一串随机生成的数字，这串数字结合索引编号和“链码”可派生出其他私钥

确定性钱包目前最高级的版本是通过BIP-32标准定义的HD钱包。HD钱包的私钥是以树状结构派生的，父私钥可以派生出一系列子私钥，每个子私钥又可以派生出一系列孙私钥，以此类推，可以无限派生。

HD钱包优点

- **树状结构可以用来表达额外的组织含义**
- 它可以让用户去**创建一系列公钥而无须知晓相对应的私钥**。这样HD钱包可在安全性不高的服务器中使用或者作为收款专用，为每笔交易提供不同的公钥。

助记词，单词序列很重要 标准由BIP-39定义 **用户可以导出在其中一个钱包上生成的助记词，并将其导入另一个钱包，以恢复所有的交易、密钥和地址。**

助记词编码是表示（可编码成）确定性钱包的随机数种子的英语单词序列。助记词足以重新创建种子，并从种子那里重新创建钱包和所有派生的私钥。

助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。钱包从熵源（随机源）开始，添加校验码（check-sum），然后将随机数映射到单词列表：

1）创建一个128～256位的随机数（熵）。

2）提取随机数的SHA256散列值的前x位（x等于随机数位数除以32）作为检验和。

3）将校验码添加到随机序列的末尾。

4）将序列按11位进行划分。

5）将每11位的值映射到一个含2048（211）个单词的预定义字典中。

6）生成的有顺序的单词组就是助记词。

助记词表示长度为128～256位的熵（随机数）。使用**密钥延伸函数PBKDF2，熵被用于派生出更长的（512位）种子**。将所得的种子用于构建确定性钱包并派生密钥。

**助记词和盐（slat）**

7）PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记词。

8）PBKDF2密钥延伸函数的第二个参数是盐。由固定的字符串“mnemonic”与可选的用户输入的密码字符串连接组成。

9）PBKDF2将助记词和盐作为参数，调用2048次HMAC-SHA512散列算法，生成一个512位的值作为其延伸的最终输出。这个512位的值就是种子。

本质上，没有“错误”的密码，所有密码都是有效的，它们只是会导致不同的种子，形成一大批可能未初始化的钱包

HD钱包从单个128位、256位，或512位的随机数根种子（root seed）中创建。最常见的情况是，这个**种子是从助记词产生**的

HD钱包中的所有私钥都是从这个根种子确定性地派生出来的 只需传输根种子的助记词即可。

创建主私钥以及HD钱包的主链码的过程：

![Untitled](./%E7%B2%BE%E9%80%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BC%96%E7%A8%8B/Untitled.png)

**主链码（c）用于从父私钥创造子私钥的那个函数中引入随机数**（熵）

分层确定性钱包使用CKD（child key derivation，子私钥派生）函数从父私钥派生出子私钥。

子密钥派生函数是基于单向散列函数的，这个函数结合了：

**一个父私钥或者公钥（ECDSA未压缩密钥）**

**一个256位的链码**

**一个32位的索引码**

**链码是用来给这个确定性过程引入随机数据的**，以便知道索引编号和子私钥也不足以派生其他子私钥

初始链码种子（在树的根部）是用根种子生成的，而后续的链码从各自的父链码中派生出来。

一个私钥、一个链码以及想要的子私钥的索引号，私钥派生函数就可以用来创建私钥树上任何层级的子私钥。**将私钥以及链码这两个重要的部分组合在一起，称为扩展密钥**（extended key）。术语“扩展密钥”也被认为是“可扩展的密钥”，因为这种密钥可以用来派生子密钥。

两种类型的扩展密钥：1）**私钥以及链码组成扩展私钥**，它可用来派生子私钥（子私钥可以用来派生子公钥）。2）**公钥以及链码组成扩展公钥**，它可以用来派生子公钥

扩展密钥使用特殊的版本号进行Base58Check编码，所以编码的字符中，会出现“xprv”或“xpub”这样的前缀（扩展私钥前缀为xprv，扩展公钥前缀为xpub）

两种生成子公钥的方法：通过子私钥生成，或者直接通过父公钥生成。

公钥部署：服务器或者应用程序可以拥有扩展公钥的副本但没有私钥。这种部署方式可以创造出无限数量的公钥以及比特币地址，但是发送到这些地址里的比特币此时都不能花费。

HD钱包使用了**强派生（hardened derivation）函数**来替代原来的派生函数。它可以“打破”父公钥以及子链码之间的关系。这个强派生函数使用了**父私钥去推导子链码**，而不是父公钥。

建议**主私钥所衍生的第一层级的子私钥都使用强派生**

区分私钥是从常规派生函数还是从强化派生函数中派生出来，索引码的取值分为两个范围。索引码在0和231-1（0x0到0x7FFFFFFF）之间的用于常规派生。索引码在231和232-1（0x80000000到0xFFFFFFFF）之间的用于强派生。因此，索引码小于231就意味着子私钥是常规的，而大于或者等于231的子私钥就是强化型的。

**强派生的索引号码也是从0开始展示的，但是右上角有一个小撇号**。

BIP-44指定了包含5个预定义树状层级的结构

第1层的purpose总是被设定为44'。

第2层的“coin_type”特指币种，允许多货币HD钱包中的货币在第二个层级下有自己的子树结构。这是目前已经定义的三种货币：Bitcoin使用m/44'/0'、Bitcoin Testnet使用m/44'/1'，以及Litecoin使用m/44'/2'。

## 交易

**比特币交易**是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了**确保比特币交易可以被生成**、**能在比特币网络中得以传播和通过验证**，并最终添加至全球比特币交易总账簿（**比特币区块链**）。比特币交易本质上包含**交易参与者价值转移的相关信息数据结构**。比特币区块链是一本全球复式记账总账簿，每笔交易都是在比特币区块链上的一个公开记录。

在比特币底层系统里，没有具体的货币，没有发送者，没有接收者，没有余额，没有账户，没有地址。所有这些概念都构建在更高的抽象层次上，是为了让使用者更容易理解比特币

比特币交易的基础组成部分是**交易输出**（transaction output）。交易输出是不可分割的比特币货币，记录在区块链上，并被整个网络识别为有效。

**比特币完整节点跟踪所有可用和可消费的输出，称为“未花费的交易输出”（unspenttransaction outputs），即UTXO。所有UTXO的集合被称为UTXO集**

UTXO集大小在新的UTXO增加时而增长，并在UTXO被消耗时而缩小。每一个交易都代表UTXO集中的变化（状态转换）。

收到比特币时，**是指钱包已经检测到钱包所控制的密钥可用的UTXO**。因此，用户的比特币“余额”是指用户钱包中可用的UTXO总和，而它们可能分散在数百个交易和区块中。用户余额，这个概念是比特币钱包应用创建的。比特币钱包通过扫描区块链并汇聚所有属于该钱包控制的私钥的UTXO来计算该用户的余额。

比特币的最小单位是八位小数的“**聪**“

UTXO是面值为“聪”的离散且不可分割的价值单位，**一个UTXO只能在一次交易中作为一个整体被消耗。**

由于UTXO的不可分割特性，大部分比特币交易都会产生**找零。**

交易会消耗先前记录的未使用的UTXO，并创建可供未来交易使用的新的UTXO。通过这种方式，大量的比特币在消费和创建UTXO的交易链中在所有者之间进行转移。

**币基交易**（Coinbase Transaction），它是每个区块中的第一笔交易，**这笔交易由“获胜”矿工设置**，创建全新比特币并支付给该矿工作为采矿奖励。币基交易并不消费UTXO，相反，它有一种称为“coinbase”的特殊类型的输入。

UTXO在UTXO集（UTXOset）中被每一个全节点比特币客户端追踪。新的交易从UTXO集中消耗（花费）一个或多个输出。

交易输出包含两部分：

一定量的**比特币**，面值为“聪”（satoshis）即最小的比特币单位

作为花费输出所需条件的**加密难题（cryptographic puzzle）锁定脚本**（locking script）、见证脚本（witnessscript），或脚本公钥（scriptPubKey）

**交易输入将UTXO（通过被引用）标记为将被消费，并通过解锁脚本提供所有权证明**。

要构建一个交易，钱包从它控制的UTXO中来选择足够的面值来执行被请求的付款。有时一个UTXO就够了，其他时候需要更多。**对于将用于此付款的每个UTXO，钱包将创建交易输入，指向此UTXO，并使用解锁脚本解锁它**。

**解锁脚本是一个证明比特币所有权的数字签名和公钥**

输入包含四个元素：

- **一个交易ID**，引用包含正在使用的UTXO的交易。
- **一个输出索引**（vout），用于标识来自该交易中的第几个UTXO被引用（第一个为零）。
- 一个scriptSig（**解锁脚本**），满足放置在UTXO上的支付条件，解锁支出。
- 一个序列号（稍后讨论）。

在编写比特币软件时，只要你想验证交易或计算交易费用或检查解锁脚本，你的代码必须首先**从区块链中检索引用的UTXO**，以便构建隐含但不存在上下文输入的UTXO引用。

大多数交易包括交易费（矿工费），以补偿比特币矿工在保障网络安全的付出。费用本身也可以作为一种**安全机制**，**因为攻击者通过海量交易攻击网络在经济上是不可行的**。

交易费是以千字节为单位计算的，而不是比特币交易的金额。总体而言，交易费是由比特币网络中的市场行为决定。矿工会依据许多不同的标准（包括费用）对交易进行优先级排序，甚至可能在某些特定情况下免费处理交易。

**费用估算算法根据容量和“竞争”交易提供的费用计算适当的费用**。这些算法的范围从简单（最后一个区块的平均费用或中值费用）到复杂的（统计分析）。算法估计必要的费用（以聪/字节为单位），这将使交易被选中并打包在后续一定数量的区块内的可能性很高。

**必须确保你没有因疏忽而将不应花费的输入变成了巨额交易费**

Eugenia的钱包应用会通过计算交易的大小并乘以每千字节需要的费用来计算适当的交易费。很多钱包会支付较大的交易费，以确保交易得到及时处理。更高的交易费不是因为Eugenia要付的钱很多，而是因为她的**交易很复杂导致数据量大**——**交易费与交易的比特币价值无关的**。

比特币交易脚本语言称为脚本，是一种类似Forth的基于栈执行的逆波兰表达式语言

放置在UTXO上的**锁定脚本和解锁脚本都是用这种脚本语言编写**的。当一笔比特币交易被验证时，每一个输入中的解锁脚本将与其对应的锁定脚本一起执行，以确定这笔交易是否满足支付条件。

**“P2PKH”（Pay-to-Public-Key-Hash**）

比特币交易脚本语言是无状态的，因为在执行脚本之前没有状态，在执行脚本之后也不保存状态。因此，执行脚本所需的所有信息都包含在脚本中。可以保证的是，**一个脚本在任何系统上都会以相同的方式执行。**

比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。**锁定脚本是一个放置在输出上面的花费条件：它指定了今后花费这笔输出必须要满足的条件。**

解锁脚本是“解决”或满足输出上**锁定脚本设定的花费条件并允许花费输出的脚本**。解锁脚本是每个**交易输入**的一部分，而且往往含有一个由**用户的比特币钱包（通过用户的私钥）生成的数字签名。**

每个比特币验证节点将**通过一起执行锁定和解锁脚本来验证交易**。每个输入都包含一个解锁脚本，并引用先前存在的UTXO。验证软件将复制解锁脚本，检索输入引用的UTXO，并从该UTXO复制锁定脚本。然后按顺序执行解锁和锁定脚本。如果解锁脚本满足锁定脚本条件，则输入有效。所有输入都是独立验证的，作为交易整体验证的一部分。

UTXO会永久记录在区块链中，因此它是不会变化的，并且不受在新交易中引用失败的尝试的影响。**只有正确满足输出条件的有效交易才能将输出视为“已用完”，并从未使用的交易输出集（UTXO集）中移除。**

比特币的脚本语言是一种基于**栈的语言 后进先出**

尽管绝大多数锁定脚本都指向一个公钥散列值（本质上就是比特币地址），因此需要所有权证明来支付资金，但脚本本身并不需要如此复杂。任何解锁和锁定脚本的组合**只要其结果为真（TRUE）**，则有效。

比特币网络处理的大多数交易花费的都是由“**付款至公钥散列**”（Pay-to-Public-Key-Hash）脚本锁定的输出，这些输出都包含一个锁定脚本，将输入锁定为一个公钥散列（hash）值，即我们常说的比特币地址。由P2PKH脚本锁定的输出可以通过提供一个**公钥和由相应私钥创建的数字签名来解锁**（使用）

只有当解锁脚本包含了咖啡馆的有效签名，交易执行结果才会通过（结果为真），该有效签名是从与公钥散列相匹配的咖啡馆的私钥中所获取的。

比特币中使用的数字签名算法是**椭圆曲线数字签名算法**（Elliptic Curve DigitalSignature Algorithm，ECDSA）。

数字签名在比特币中有三种用途。第一，**签名证明私钥的所有者**，即资金所有者，已经授权支出这些资金。第二，授权证明是**不可否认**的（不可否认性）。第三，签名证明交易（或交易的特定部分）在签名之后没有也**不能被任何人修改**。

数字签名是一种由两部分组成的数学方案：第一部分是使用私钥（签名密钥）从消息（交易）创建签名的算法；第二部分是允许任何人在给定消息和公钥时验证签名合法性的算法。

**被签名的“消息”是交易**，或者更准确地说是交易中特定数据子集的散列。签名密钥是用户的私钥。结果是签名

要验证签名，必须有签名（R和S）、序列化交易和公钥（对应于用于创建签名的私钥）。本质上，签名的验证意味着“**只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。**”签名验证算法采用消息（交易或其部分的散列值）、签名者的公钥和签名（R和S值），如果签名对该消息和公钥有效，则返回TRUE值。

随机性在签名中的重要性 签名生成算法使用随机密钥k作为短暂私钥/公钥对的基础。k的值并不重要，只要它是随机的。如果使用相同的值k在不同的消息（交易）上生成两个签名，那么任何人都可以计算出签名私钥。**在签名算法中重用相同的k值的会导致私钥的暴露**！

重用k值的最常见原因是随机数生成器未正确初始化。

**使用交易数据本身播种的确定性随机进程。这确保每个交易产生不同的k值**。

交易本身并不包含比特币地址，而是**通过锁定和解锁比特币面值的脚本进行操作**。区块链系统中的任何地方都不存在余额，而每个钱包应用程序都明明白白地显示了用户钱包的余额。

构建“总收到”金额，区块链浏览器首先解码比特币地址的Base58Check编码，以检索地址中编码的Bob的公钥的160位散列值。然后，区块链浏览器将搜索交易数据库，**查找使用包含Bob的公钥散列的P2PKH锁定脚本输出**。通过计算所有输出的值，区块链浏览器可以生成收到的总值。

为了构建当前余额（显示为“最终余额”）需要更多的工作。**区块链浏览器将当前未使用的输出作为单独的数据库，即UTXO集**。为了维护此数据库，区块链浏览器必须实时监控比特币网络，添加新创建的UTXO，并删除实时已使用的UTXO，只要它们出现在未经确认的交易中。这是一个复杂的过程，不但要实时地跟踪交易在网络上的传播，同时还要保持与比特币网络的共识，确保在正确的区块链上。有时区块链浏览器未能保持同步，导致其对UTXO集的跟踪扫描不完整或不正确。通过计算UTXO集，**区块链浏览器计算了引用Bob的公钥散列的所有未使用输出的值，并产生向用户显示的“最终余额”数目**。

通过钱包应用程序、区块链浏览器和其他比特币用户界面呈现给用户的信息通常源于更高层次的抽象概念组成，这些概念通过搜索许多不同的交易，检查其内容以及整合其中包含的数据而构成。为了将比特币交易呈现出类似于银行支票从发送人到接收人的这种简单视图，这些应用程序必须抽象许多底层细节。应用程序主要关注常见的交易类型：每个输入上具有SIGHASH_ALL签名的P2PKH。因此，虽然比特币应用程序以易于阅读的方式呈现了80％以上的交易，但有时候会偏离常规的交易。有些交易包含更复杂的锁定脚本，或不同的SIGHASH标志，或许多输入和输出，这些交易显示了这些抽象概念的简单性和弱点。

## 高级交易及脚本

多重签名脚本设置了一个条件，其中N个公钥被记录在脚本中，并且必须提供至少M个签名才能解锁资金。这也称为**M-N方案**，其中N是密钥的总数，M是验证所需的签名的数量。

只有在解锁版脚本与锁定脚本设置的条件匹配时，此组合脚本才会得到结果为真（Ture）

解锁脚本，你应该期望在开始时看到一个额外的0，它唯一的目的是解决一个bug，却意外地成为一个共识规则

P2SH（Pay-to-Script-Hash）在2012年被作为一种新型、强大且能大大简化复杂交易脚本的交易类型而引入它**旨在使复杂脚本的使用能与直接向比特币地址支付一样简单**。通过P2SH支付，**复杂的锁定脚本将被其数字指纹（一种加密散列）所取代**。当稍后试图花费此UTXO时，除了解锁脚本外，它还必须包含与散列值相匹配的脚本。简而言之，**P2SH的意思是“支付与该散列值相匹配的脚本，这个脚本将在输出被使用时出示”**。

在P2SH交易中，**由散列值代替的锁定脚本被称为兑换脚本，取代“向5个多重签名脚本支付”，这个P2SH等同于“向符合该散列的脚本支付”**

P2SH的另一重要特征是它能将脚本散列编码为一个地址，如BIP-13中所定义的。P2SH地址是脚本的20字节散列的Base58Check编码，就像比特币地址是公钥的20字节散列的Base58Check编码一样

与直接使用复杂脚本以锁定输出的方式相比，P2SH具有以下**优点**：

- 在交易输出中，复杂脚本由简短散列值代替，使得交易代码变短。
- 脚本能被编译为地址，支付指令的发出者和支付者的比特币钱包不需要复杂的实现就可以执行P2SH。
- P2SH将构建脚本的工作转移至接收方，而非发送方。
- P2SH将长脚本数据存储的负担从输出侧（需要存储于UTXO集，过大影响内存）转移至输入侧（长脚本存储在区块链）。
- P2SH将长脚本数据存储的负担从当前（交易时）转移至未来（花费时）。
- P2SH将长脚本的交易费成本从付款方转移至收款方，收款方在使用该笔资金时必须包含兑换脚本。

因为兑换脚本只有在你试图花费一个P2SH输出时才会在比特币网络中出现，假如你将输出与一个无效的兑换脚本的散列进行锁定，它将会被执行，该UTXO将会被成功锁定，但是你将无法使用这笔资金，因为包含无效兑换脚本的支出交易不会被接受。这样的处理机制也衍生出一个风险，**因为你可以将比特币锁定在一个不能使用的P2SH中**。

**数据记录输出（RETURN操作符）**

比特币的去中心特点和时间戳账本机制，即区块链技术，其潜在用途将大大超出支付领域。

return操作符最终实现了妥协。Return允许开发者在交易输出上增加80个字节的非交易数据。与伪交易型的UTXO不同，Return创造了一种明确的可复查的非交易型输出，此类数据无须存储于UTXO集。Return输出被记录在区块链上，**它们会消耗磁盘空间，也会导致区块链规模的增加，但它们不存储在UTXO集中，因此也不会导致UTXO膨胀从而占用昂贵的内存让全节点都不堪重负。**

没有与RETURN对应的可以花费RETURN输出“解锁脚本”。RETURN不能使用其输出中所锁定的资金，因此它也就没有必要记录在蕴含潜在成本的UTXO集中，所以RETURN实际是没有成本的。

**时间锁（Timelocks）是只允许在某个时间点之后才可以被支出的交易或输出**。比特币从一开始就有一个交易级的时间锁定功能。

比特币从一开始就有一个交易级的时间锁功能。交易锁定时间（nLocktime）是交易级设置（交易数据结构中的一个字段），它定义交易有效的最早时间，并且可以在网络上传输或添加到区块链中。锁定时间也称为nLocktime 使用nLocktime相当于一张远期支票。

nLocktime有一个局限性，虽然它可以在将来花费一些输出，但它不会使用户在那之前花费不了。

检查锁定时间验证 CLTV是每个输出的时间锁定，而不是和nLocktime一样的交易时间锁定。这可以在**应用时间锁的方式上提供更大的灵活性**。

nLocktime是交易级别的时间锁，**CLTV是输出级别的时间锁**。

相对时间锁 特征是锁定时间是相对，因为它们将消耗输出的条件指定为输出从区块链中确认的经过时间。相对时间锁是有用的，因为它们**允许将两个或多个相互依赖的交易链接在一起，同时对依赖于从先前交易的确认所经过的时间的一个交易施加时间约束**。

相对时间锁（如绝对时间锁定）同时具有交易级功能和脚本级操作码。交易级相对时间锁定是基于对每个交易输入中设置的交易字段nSequence的值的共识规则实现的。**脚本级相对时间锁定使用CHECKSEQUENCEVERIFY（CSV）操作码实现。**

**nSequence作为一个共识的相对时间锁** 新的共识规则适用于任何包含nSequence并且值小于232的输入的交易（bit 1<<31 is not set）。在编程语言里，这意味着如果没有设置最高有效（bit 1<<31），它是一个表示“相对锁定时间”的标志。否则（bit 1<<31set），nSequence值被保留用于其他用途

就像CLTV和nLocktime一样，有一个脚本操作码用于相对时间锁定，它将利用脚本中的nSequence值。该操作码是CHECKSEQUENCEVERIFY，通常简称为CSV。在UTXO的兑换脚本中验证时，CSV操作码仅允许输入的nSequence值大于或等于CSV参数的输入，才可以在交易中花费。实质上，这限制了UTXO的即时使用，直到此UTXO被打包到区块链，并过了一定数量的块或秒。

**过去中位时间 该机制通过获取最后11个块的时间戳并计算其中位数作为“过去中位时间”的值。这个中间时间值就变成了共识时间，并被用于所有的时间计算**。通过取从过去大约两个小时区块的中位时间，任何一个单独块的时间戳的影响都会减小。通过这个方法，没有一个矿工可以利用时间戳从具有尚未到期的时间锁的交易中获取非法矿工费。

**费用狙击（**Fee Sniping）是一种理论攻击情形，矿工试图从将来的块中（从最新的交易池中挑选手续费较高的交易）重写过去的块，实现“狙击”更高费用的交易，以最大限度地提高盈利能力。为了防止“费用狙击”，当Bitcoin Core钱包创建交易时，默认情况下，**它将使用nLocktime将它们限制为“下一个块”。**

**比特币条件操作码**允许我们构建一个具有两种解锁方式的兑换脚本，这取决于验证逻辑条件的TRUE/FALSE结果。例如，如果x为TRUE，则兑换脚本为A，ELSE兑换脚本为B。

嵌套没有限制，但共识规则会对脚本的**最大大小（以字节为单位）施加限制**。

VERIFY后缀表示如果评估的条件不为TRUE，脚本的执行将立即终止，并且该交易被视为无效。与提供替代执行路径的IF子句不同，VERIFY后缀充当保护语句，只有在满足前提条件的情况下才会继续。

**如果我们想要做的是附加一个前提条件（保护条件语句），那么VERIFY是更好的。然而，如果我们想要有多个执行路径（流控制），那么我们需要一个IF...ELSE流控制子句**。

比特币脚本中**流控制**的一个常见的用途是构建一个提供多个执行路径的兑换脚本，每个路径都有一种不同的兑换UTXO的方式。

## 比特币网络

比特币是在互联网之上依照点对点网络架构来设计的。点对点（peer-to-peer），或者说**P2P**，是指参与网络的每台计算机都是平等的，不存在“特殊”节点，所有节点分担提供网络服务的压力。网络节点以一种“扁平”拓扑结构在网状网络中相互连通。

**一个P2P网络中的各节点同时提供服务和消费服务，这种互惠运作就是他们参与的动机。P2P网络天生具有弹性、去中心化和开放的特征**

比特币网络”指的是运行比特币P2P协议的节点集合。

我们使用“扩展比特币网络”来代指包括了比特币P2P协议、矿池挖矿协议、Stratum协议以及其他任何连接比特币系统组件的相关协议的整体网络。

**一个比特币节点是一个功能集合：路由、区块链数据库、挖矿和钱包服务 NBMW**

**所有节点必须包括路由功能**，同时还可能包括其他功能。所有节点都验证和传播交易与区块，并发现维护与对等节点的连接。

**全节点可以无须任何外部参照地自主验证任何交易。**一些节点仅仅维护了区块链的一个子集，它们通过一种叫作“简易支付验证”（Simplified payment Verification，**SPV**）的方法验证交易。这些节点被称为SPV节点或轻量节点。

挖矿节点通过运行在特殊硬件上的**工作量证明**（Proof-of-Work）算法，以相互竞争的方式创建新的区块。一些挖矿节点同时也是全节点，维护了区块链的完整副本；其他的是轻量节点，参与矿池挖矿，它们依赖于矿池服务器来维护一个全节点。

许多大公司通过运行**基于比特币内核客户端的全节点客户端来接入比特币网络，它们具备区块链的完整副本和网络节点，但不具备挖矿和钱包的功能**。这些节点作为网络的边缘路由器，通过它们能构建其他服务（交易所、钱包、区块浏览器、商家支付处理）等。

连接在比特币P2P主网上的是一些矿池服务器以及协议网关，它们把运行其他协议的节点连接起来。这些节点大都是矿池挖矿节点（参见第10章）和轻量钱包客户端，它们通常不带有区块链的完整备份。

比特币矿工已经被卷入了一场关于解决工作量证明和延伸区块链问题的竞争，这个竞争是非常时间敏感的。在这场竞争中，比特币矿工必须最小化在传播一个获胜区块和开始下一轮竞争之间的时间。在挖矿行业，**网络延时直接和利润率相关**。

**比特币中继网络**是一个尝试最小化在矿工之间传送区块延时的网络

中继网络不是比特币P2P网络的替代品。相反，它们是覆盖网络，为存在特殊需求的节点之间提供额外的链接。

当一个新的节点启动后，为了参与网络协同，它必须发现网络中其他的比特币节点。为了开始这个过程，一个新节点必须至少发现一个现存网络节点并连接上它。因为比特币网络拓扑不以地理位置定义，其他节点的地理位置是完全无关的，所以任意现有比特币节点可以随机选取。

version（版本）消息始终是从一个节点到另一个节点发送的第一条消息。收到version消息的本地节点会检查远程节点报告的nVersion内容以判断远程节点是否兼容。如果远程节点兼容，本地节点会确认version信息并通过回送一个verack建立连接。

一个新节点如何发现对等节点：**DNS种子** 返回的一个比特币节点地址列表的随机子集，这个列表通过一个爬虫或者长时间运行的比特币节点来收集。比特币核心客户端包含五个不同DNS种子的名字。**对网络完全不了解的引导节点必须被提供至少一个比特币节点的IP地址**，在这之后它可以通过进一步引导建立连接。

一个节点必须连接到若干个不同的对等节点以建立进入比特币网络的不同路径。路径并不是一直可靠的（因为节点可以随时加入和离开），所以当节点丢失老的连接时，还有为其他节点提供引导辅助时，它必须持续发现新节点。新节点开始引导的时候只需要一个链接，因为第一个节点可以引导到它的对等节点，而这些对等节点可以提供进一步的引导。

如果一个连接上没有通信，节点会定期发送一个消息以维持这个连接。如果一个节点在一个连接上超过90分钟没有通信，它会被认为已经从这个连接断开并寻找一个新的对等节点。这样，**网络对动态节点和网络问题进行动态调整，在没有中央控制的情况下有机地增长和收缩**。

全节点是维护了包含全部交易的一个全区块链节点。更准确地说，它们应该被称为“**全区块链节点**”。

**一个全区块链节点可以独立可信地验证任何交易**，而无须求助于或者依赖于其他节点或是信息源。全区块链节点依赖网络来接收关于新交易区块的更新，在验证之后合并到它本地的区块链副本中。

从#0号区块（创世区块）开始，新节点必须下载成千上万的区块以和网络同步并重建完整区块链。

一个节点会从它的对等节点看到version消息，知道对等节点拥有的区块数量，进而和自己区块链上的区块数量进行比较。对等节点会交换一个包括它们本地区块链顶部区块散列值（指纹）的getblocks消息。如果一个对等节点能识别出接收到的散列值属于一个非顶部区块，而是属于一个更老的区块，那么就可以推断出它本地的区块链比它对等节点的区块链更长。

它会识别出第一批500个区块，**使用一个inv（库存）消息来分享和传送它们的散列值**。缺少这些区块的节点之后就可以通过发送一系列getdata消息，使用来自inv消息的散列值信息来识别需要的区块并请求完整区块数据。

**请求负载是分散的**以保证它不会冲垮任何一个对等节点。持续到节点和网络其他节点完成同步。

当一个节点离线，不论离线时间有多长，这个比较本地与对等节点的区块链，并接收缺失区块的过程就会被触发。

简易支付验证（SPV）节点 SPV节点**仅下载区块头而不下载每个区块内包括的交易。**由此得到的不包含交易的区块链，比完整区块链要小1000倍。SPV节点无法构建所有可用的UTXO的全貌，因为它们不知道网络上的全部交易。SPV节点的交易验证方法略有不同，它们依赖于对等节点按需提供区块链相关部分的局部视图。

SPV通过参考**区块链的深度而非高度来验证交易**

SPV节点通过请求一个merkle路径的证明并验证区块链上的工作量证明，来确认一笔交易在一个区块中的存在。**一个SPV节点需要随机连接到一些节点来提升它至少联系到一个诚实节点的可能性**

比特币开发者增加了一个叫作**bloom过滤器**的功能来解决SPV节点的隐私风险。Bloom过滤器通过使用概率而非固定模式的过滤方法，允许SPV节点在不需要精确指定它们关心的地址的情况下接收一个交易子集。

bloom过滤器由一个可变长度的位数组（即N位二进制数，每个数组成员是一个位）和数量可变（M）的一组散列值函数构成。这些散列值函数被设计成根据位数组产生一个在1和N之间的输出。这些散列值函数是确定性的，所以任何实现了一个bloom过滤器的节点会始终使用同一个散列值函数，对于同一个特定输入会得到同样的结果。通过选择不同长度（N）的bloom过滤器和不同数字M的散列值函数集合，bloom过滤器的准确性和隐私性可以被调节。

**一个bloom过滤器的正面匹配意味着“可能是”**

**SPV节点之后会发送一个filterload消息给对等节点，包含了要在连接上使用的bloom过滤器。在对等节点上，针对每笔传入交易检查过滤器。全节点根据bloom过滤器检查交易的几个部分来寻找匹配**

Bloom过滤器是降低隐私损失的方法

提升比特币P2P网络隐私性和安全性的一种方法，有两种通信加密的解决方案：Tor传输和BIP-150/151下的P2P认证和加密。

洋葱路由网络（The Onion Routing network），它是一个通过匿名、不可追溯和隐私性的随机网络路径来提供数据加密和封装的软件项目和网络

如果P2P加密被广泛部署，会加强比特币对流量分析和侵犯到隐私的监视的抵抗能力，尤其是在互联网使用受到严格控制和监控的极权国家。

几乎比特币网络上的每个节点都维护了一个叫作**内存池或者交易池的未确认交易临时列表**。节点用这个池子来跟踪已经被网络感知但还没有被包括到区块链的交易。举个例子，一个钱包节点使用交易池来跟踪已经被网络接收但还没被确认的进入用户钱包的支付。

当一笔交易被加入交易池，会首先检查孤儿交易池来判断里面是不是有引用到这笔交易输出的交易（它的孩子）。**任何匹配的孤儿交易会跟着被检验。如果有效，则从孤儿交易池中移除，加入交易池**，使以父交易开始的链变得完整。对于新近被加入的不再是一个孤儿的交易，这个过程会重复递归地寻找下一步的后代，直到所有的后代都被发现。通过这个过程，**父交易的到达触发了一整条相互依赖交易的链的级联重建**，沿着整条链将孤儿交易和它们的父交易组合在一起。

**交易池和孤儿池代表了单个节点的本地视角，不同节点取决于各自启动或重启时间的不同可能有很大差别。UTXO池代表的是网络的浮现共识，因此节点之间的差异很小。此外，交易池和孤儿池仅包含未确认交易，而UTXO池仅包含确认交易。**

## 区块链

**区块链数据结构是一个有序的，反向链接的交易块列表**。区块链可以作为平面文件（Flat File）存储，也可以存储在简单的数据库中。

**区块链通常被显示为一个垂直栈**，其中区块彼此堆叠，最底下的第一个区块作为栈的基础。人们根据这一个摞一个的区块形象设计了一些相关的术语，诸如“高度”指离开第一个区块的距离，而“顶部”或“顶端”指的是最近添加的区块。

区块链中的每个区块都由一个散列值来标识，这个散列值是对区块头（blockheader）使用SHA256加密散列算法得到的。每个区块都可以通过其区块头中包含的其父区块的散列值来找到其前一个区块（父区块）。**每个区块的区块头中都包含它的父区块的散列值**。这样环环相扣把每个区块链接到各自父区块的散列值序列就是一条可以一直追溯到第一个区块（创世区块）的链条。

一个区块只有一个父区块，但它可以**暂时拥有多个子区块**。每个子区块都将指向同一父区块，并且在“父区块散列值”字段中具有相同的（父区块）散列值。在区块链“分叉”期间出现了多个孩子，这是一种临时情况，当不同的区块几乎同时被不同的矿工发现时会发生这种情况

父区块散列值”字段储存在区块头里面，因此会影响区块本身的散列值。**如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化**。当父区块有任何改动时，父区块的散列值会发生变化。这将使子区块的“父区块散列值”字段发生改变，从而将使得子区块的散列值发生改变。而子区块的散列值发生改变将使孙区块的“父区块散列值”字段发生改变，因此又会改变孙区块的散列值，以此类推。这种级联效应可以确保一旦一个区块在其之后有许多后代，它就不能在不强制重新计算所有后续区块的情况下进行更改。由于重新计算需要大量的算力（需要耗费大量的能源），**长链块的存在使得区块链的纵深历史变得不可篡改，这是比特币安全性的一个关键特征。**

一旦深入区块链超过六个区块，区块被修改的可能性就越来越小。100个区块以后，区块链的稳定性非常之高

区块是一种容器型的数据结构，聚合了被记录在公开账簿（区块链）里的交易信息。区块由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头为80个字节，而平均每个交易至少为250个字节，平均每个区块包含超过500个交易。因此，一个包含所有交易的完整区块比区块头大1000倍

区块头包含三组区块元数据。首先，有一组引用**父区块散列值**的数据，这组元数据用于将该区块与区块链中前一区块相连接。第二组元数据，即**难度、时间戳和随机数**，与挖矿竞争相关。第三块元数据是**默克尔树根**（merkle treeroot），一种数据结构，用于有效地汇总块中的所有交易。

区块主要标识符是它的加密散列值 **区块散列唯一且明确地标识一个区块**，并且可以**由任何节点通过简单地对区块头进行散列运算来独立地导出**。

识别区块的第二种方法是**根据其在区块链中的位置，称为区块高度 与区块散列值不同，区块高度不是唯一标识符。尽管单个区块总是具有特定且不变的区块高度，但反过来并不正确。区块高度并不总是标识单个区块。**

区块高度也不是区块数据结构的一部分；它不存储在区块中。当从比特币网络收到区块时，每个节点都会动态识别区块在区块链中的位置（区块高度）。区块高度也可以作为元数据存储在索引数据库表中以加快检索速度。

区块链中的第一个区块被称为**创世区块** 从任何区块开始并按时序回溯区块链的话，最终都将到达创世区块。

每个节点总是以至少一个区块的区块链开始

比特币的全节点在本地保存了区块链从创世区块起的完整副本。区块链的本地副本会随着新区块的发现并用于扩展区块链而不断更新。

节点会在previousblockhash（父区块哈希值）字段里找出包含其父区块的哈希值

比特币区块链中的每个区块都包含该区块中所有的交易，以**默克尔树**（merkletree）来表示。

默克尔树，也称**为哈希二叉树，是一种用于有效地汇总和验证大型数据集完整性的数据结构。默克尔树是包含密码哈希的二叉树**。

在比特币中使用默克尔树来汇总区块中的所有交易，为整个交易集提供全面的数字指纹，提供非常高效的流程来验证交易是否包含在区块中。生成一棵完整的默克尔树需要**递归地将一对节点进行哈希，并将新生成的哈希节点插入默克尔树中，直到只剩一个哈希节点，该节点就是默克尔树的根。**在比特币的默克尔树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。

一个节点只要计算log2（N）32字节的哈希值，形成一条从特定交易到树根的认证路径或者默克尔路径。随着交易数量的增加，这样的计算量就显得尤为重要，因为相对于交易数量的增长，以基数为2的交易数量的对数的增长速度会慢得多。

有了默克尔树，一个节点能够仅下载区块头（80字节/区块），然后通过从一个全节点回溯一条小的默克尔路径就能认证一笔交易的存在，而不需要存储或者传输大量区块链中大多数的内容，那些也许有几个GB的大小。这种不需要维护一条完整的区块链的节点，被称作**简单支付验证（SPV）节点**，它通过默克尔路径去验证交易的存在，而不需要下载整个区块。

默克尔树被SPV节点广泛使用。SPV节点不保存所有交易也不下载整个区块，仅保存区块头。它们使用认证路径或者默克尔路径来验证交易存在于区块中，而不必下载区块中所有的交易。

例如，一个SPV节点对它钱包中某个比特币地址即将收到的付款感兴趣。该节点会在节点间的通信链接上建立起bloom过滤器（请参阅8.9节），限制只接受含有目标比特币地址的交易。当同伴探测到某交易符合bloom过滤器要求，它将以merkleblock消息的形式发送该区块。merkleblock消息包含区块头以及将感兴趣的交易链接到区块中的根的默克尔路径。SPV节点能够使用该路径找到与该交易相关的区块，进而验证对应区块中该交易的存在。SPV节点同时也使用区块头去关联区块和区块链中的其余区块。这两种关联（交易与区块、区块和区块链）可以证明交易存在于区块链。总而言之，**SPV节点会收到少于1KB的有关区块头和默克尔路径的数据**，其数据量约为一个完整区块（目前大约有1MB）的千分之一。

testnet是测试区块链、网络和货币的总称

## 挖矿与共识

**挖矿是一种去中心化的交易清算机制，通过这种机制，交易得到验证和清算**。挖矿是使得比特币与众不同的发明，它实现去中心化的安全机制，**是P2P数字货币的基础**。

**挖矿确保了比特币系统安全，并且在没有中央权力机构的情况下实现了全网络范围的共识**。新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励方案，并同时实现了货币发行。

矿工们验证每笔新的交易并把它们记录在总账簿上。平均每10分钟就会有一个新的区块被“挖掘”出来，每个区块里包含着从上一个区块产生到目前这段时间内发生的所有交易，这些交易被依次添加到区块链中。我们把**包含在区块内并且被添加到区块链上的交易称为“确认”（confirmed）交易**，交易经过“确认”之后，新的拥有者才能够花费他在交易中得到的比特币。

两种类型的奖励：创建新区块的**新币奖励**，以及该区块中所有交易的**交易费**。

工作量证明的难题的**答案会放在新区块中**，作为矿工付出大量计算工作的证据。在工作量证明的竞争中，获胜者会得到奖励并且拥有在区块链上的**记账权**，这是比特币安全模型的基础。

挖矿之所以被称为挖矿，是因为它的奖励机制被设计为收益递减模式 矿工通过创造一个新区块得到的比特币数量大约每四年（或准确说是每210000个块）减少一半。开始时间为2009年1月，每个区块奖励50个比特币，然后到2012年11月减半为每个区块奖励25个比特币。之后在2016年7月再次减半为每个新区块奖励12.5个比特币。基于这个公式，比特币挖矿奖励以指数方式递减，直到2140年。届时所有的比特币（20，999，999，980）全部发行完毕。换句话说在**2140年之后，不会再有新的比特币产生**。

大部分收益仍来自挖矿所得的比特币奖励。然而随着挖矿奖励的递减，以及每个区块中包含的交易数量的增加，交易费在矿工收益中所占的比重将会逐渐增加。在2140年之后，矿工的所有收益都将由交易费构成。

总量有限并且发行速率递减创造了一种**抗通胀的货币供应模式**。法币可被中央银行无限制地印刷出来，而比特币永远不会因超额印发而出现通胀。

去中心化的自发共识（emergent consensus）机制。这种自发是指共识没有明确的完成点，因为共识达成时，没有明确的选举和固定时刻。换句话说，**共识是数以千计的独立节点遵守了简单的规则通过异步交互自发形成的产物**。所有的比特币属性，包括货币、交易、支付以及不依靠中心机构和信任的安全模型等都依赖于这个发明。

比特币的去中心化共识由所有网络节点的4种**独立过程相互作用**而产生：

- 每个全节点依据规范清单对每个交易进行独立验证。
- 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块。
- 每个节点独立对新区块进行校验并组装进区块链。
- 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。

**钱包通过收集UTXO、提供正确的解锁脚本、构造一个新的支出（支付）给接收者这一系列的动作来创建交易。产生的交易随后将被发送到比特币网络邻近的节点，从而使得该交易能够在整个比特币网络中传播**

每一个节点在校验每一笔交易时，都需要对照一个规范清单

在收到交易后，每一个节点都会在全网广播前先对这些交易进行独立校验，并以接收时的相应顺序，**为这些有效的新交易（还未确认）建立一个池，这个池可以叫作交易池，也称为内存池**

**新区块并不仅仅是象征着竞赛结束的方格旗，它也是下一个区块竞赛的发令枪。**

区块中的第一笔交易是一笔特殊交易，称为**创币交易**（coinbase transaction）。这个交易是由Jing的节点构造并用来奖励矿工们所做的贡献的。

与常规交易不同，**创币交易没有输入，不消耗UTXO**。它只包含一个被称作“创币”的输入，用来创建新的比特币。创币交易有一个输出，支付到这个矿工的比特币地址

不正确的奖励将被其他人视为无效，从而浪费了Jing用于工作量证明的电力投入。只有这个区块被大家认可，才能得

挖矿的目标是找到一个使区块头散列值小于难度目标的随机数。挖矿节点通常需要尝试数十亿甚至数万亿个不同的随机数取值，才会找到一个满足条件的随机数值。

挖矿就是不断修改区块头中的参数，并计算区块头的散列值，直到其散列值与目标难度相匹配的过程。散列函数的结果无法提前得知，也没有能得到一个特定散列值的模式。散列函数的这个特性意味着：**得到散列值的唯一方法是不断地尝试，每次随机修改输入，直到出现适当的散列值。**

任何人都可以用相同的散列函数计算和验证散列结果。**一个加密散列函数的主要特征就是不同的输入不可能出现相同的数字指纹**（称为冲突）。因此，除了用随机的方式生成想要的散列值以外，有意地选择一个输入去生成想要的散列值是不可能的。

目标（target）阈值，我们的目的是找到一个小于这个目标阈值的散列值。如果我们**减小这个目标阈值，那找到一个小于它的散列值会越来越难**。

可以从目标难度来估算出成功所需要的工作量。当算法是基于诸如SHA256的确定性函数时，那么必须要有一定的工作量才能产生出低于目标的结果，能够产生正确结果的输入值就是工作量的证明。这就是工作量证明（Proof-of-Work）的由来。

尽管每次尝试产生一个随机的结果，但是任何结果的概率可以预先计算。因此，**特定难度的目标代表了具体的工作量**。

难度目标 它的值为0x1903a30c。这个标记的值被存为系数/指数格式，前两位十六进制数字为指数，接下来的六位为系数。在这个区块里，0x19为指数，而0x03a30c为系数。

比特币的区块平均每10分钟生成一个。这是比特币的心跳，也是货币发行速率和交易结算速度的基础。

**难度是一个动态的参数，会定期调整以达到每10分钟一个新区块的目标。简单地说，难度会根据当前全网的挖矿能力进行调整，从而保证10分钟产生一个新区块的周期。**

每2016个区块被产生后，所有节点都会调整难度。难度的调整是由最近2016个区块的花费时长与20160分钟（即以标准10分钟一个区块的产生周期所花费的时长）比较得出的。

为了防止难度的变化过快，每个**周期的调整幅度必须小于一个因子（值为4）**。如果要调整的幅度大于4倍，则按4倍调整。由于在下一个2016区块的周期不平衡的情况会继续存在，所以进一步的难度调整会在下一周期进行。**因此平衡散列运算能力和难度的巨大差异有可能需要花费几个2016区块周期才会完成。**

目标难度与交易的数量、金额无关。这意味着散列算力的强弱以及让比特币更安全的电力投入量，与交易的数量完全无关。换句话说，当比特币的规模变得更大，使用它的人数更多时，即使散列算力保持当前的水平，比特币的安全性也不会受到影响。散列算力的增加表明更多的人为得到比特币回报而加入了挖矿队伍。只要为了回报，公平正当地从事挖矿的矿工群体保持足够的散列算力，“接管”攻击就不会得逞，这让比特币的安全无虞。

Jing的挖矿节点立刻将这个区块发给所有相邻节点。这些节点在接收并验证这个新区块后，也会继续传播它。当这个新区块在网络中扩散时，每个节点都把这个新区块加入到自身的区块链副本中，并把区块链扩展到高度277，316。当挖矿节点收到并验证了这个新区块后，它们会放弃对这个相同高度区块的计算，将Jing的区块作为父区块，立即开始计算区块链中下一个区块。矿工们在Jing新发现的区块之上构建新区块，这实际上是**使用自己的挖矿算力进行投票，支持Jing的区块以及被该区块扩展的区块链**。

每个节点独立验证每个新区块 确保了矿工无法欺诈，这是因为每一个节点都会根据相同的规则对区块进行验证。一个无效的创币交易将使整个区块无效，还会导致该区块被拒绝，因此，该交易不会成为总账的一部分。矿工必须根据所有节点遵循的共同规则构建一个完美的区块，并通过正确的工作量证明方案来挖掘它。

节点维护三种区块：第一种是连接到**主链上的**，第二种是从主链上产生分支的（**备用链**），最后一种是在已知链中找不到父区块的（**孤块**）。在验证过程中，一旦发现有任何一条不符合规范，验证就会失败，这个区块就会被节点拒绝，所以也不会被加入到任何一条链中。

任何时候，**主链都是所有有效链中累计了最多工作量证明的那条区块链**。在一般情况下，主链也是包含最多区块的那个链，也存在有两个等长的链，但是必定其中有一个有更多的工作量证明。

主链也会有一些分支，这些分支中的区块与主链上的区块互为“兄弟”区块。这些区块是有效的，但不是主链的一部分。保留这些分支的目的是如果在未来的某个时刻它们中的一个延长了并在累积工作量证明上超过了主链，那么后续的区块就会引用它们。

孤块会被保存在孤块池中，直到节点收到它们的父区块。**一旦收到了父区块并且将其连接到现有区块链上，节点就会将孤块从孤块池中取出**，并且连接到它的父区块，让它作为区块链的一部分。当两个区块在很短的时间间隔内被挖出来，节点有可能会以相反的顺序（子在父之前）接收到它们，此时孤块现象就会出现。

通过选择有效的最大累计工作量区块链，所有的节点最终在全网范围内达成共识。随着更多的工作量证明被添加到链中，扩展了可能的链中的一条，链的暂时性差异最终会得到解决。挖矿节点通过选择它们想要延长的区块链进行“投票”。当它们挖出一个新块并且延长了一个链，新块本身就代表它们的投票。

区块链的分叉 **每一个节点总是选择并尝试延长累计了最大工作量证明的区块链，也就是最长的或最大累计工作量链**。节点通过累加链上的每个区块的工作量，得到这个链的工作量证明的总量。**只要所有的节点选择最大累计工作量链，整个比特币网络最终会收敛到一致的状态。**区块链版本的临时差异会导致分叉，随着更多的区块添加到了某个分叉中，这个问题便会迎刃而解。

分叉问题几乎总是在一个区块的数量级别内就被解决了。网络中的一部分算力专注于“三角形”区块为父区块，在其之上建立新的区块；另一部分算力则专注在“倒三角形”区块上。**即便算力在这两个阵营中平均分配，也总有一个阵营抢在另一个阵营前发现工作量证明解并将其传播出去**。

比特币将区块间隔设计为**10分钟**，是在**更快速的交易确认（交易结算）和更低的分叉概率间做出的妥协**。更短的区块产生间隔会让交易清算更快完成，也会导致更加频繁的区块链分叉。与之相对地，更长的间隔会减少分叉数量，却会导致更长的结算时间。

区块头需要一个新的随机数值的来源 解决方案是使用**创币交易作为额外的随机数值来源**

矿工们合作组成**矿池**，汇集数以千计参与者们的算力并分享奖励。通过参加矿池，矿工们虽然只能得到整体奖励的一小部分，但几乎每天都能得到，因而减少了不确定性。

矿池如何衡量每个人的贡献，既能公平分配奖励，又避免作弊的可能？答案是使用比特币的工作量证明算法来衡量每个矿池矿工的贡献，但设置的难度较小，以至于即使是矿池中最小的矿工也经常能分得奖励，这足以激励他们为矿池做出贡献。通过设置一个较低的取得份额的难度，矿池可以计量出每个矿工完成的工作量。每当矿工发现一个小于矿池难度的区块头散列值，就证明了它已经完成了分配给自己的寻找结果所需的散列计算。

1.托管矿池 2.P2P矿池（P2Pool）

**共识攻击**

理论上，比特币的共识机制是容易被矿工（或矿池）试图使用自己的算力实行欺骗破坏进行攻击的。就像我们前面讲的，比特币的共识机制依赖于这样一个前提，那就是绝大多数的矿工，出于自己利益最大化的考虑，都会通过诚实地挖矿来维持整个比特币系统。然而，当一个或者一群矿工拥有了整个系统中大量算力之后，他们就可以通过攻击比特币的共识机制来达到破坏比特币网络的安全性和可靠性的目的。

共识攻击只能影响整个区块链未来的共识，或者说，**最多能影响最近的区块的共识（最多影响过去几十个块）**。而且随着时间的推移，整个比特币区块链被篡改的可能性越来越低。

区块链分叉/双重支付攻击指的是**攻击者通过从指定区块之前的区块开始分叉**，**导致其后的已经确认的区块无效**，然后重新收敛这些区块到一个替代的区块链。有了充足算力的保证，一个攻击者可以一次性篡改最近的6个或者更多的区块，从而使得这些区块包含的本应无法篡改的交易无效。值得注意的是，**双重支付只能在攻击者拥有的钱包所发生的交易上进行，因为只有钱包的拥有者才能生成一个合法的签名用于双重支付交易。攻击者在自己的交易上进行双重支付攻击，如果可以通过使交易无效而实现一种不可逆转的且不用付款的购买行为，这种攻击就是有利可图的。**

双重支付可以有两种方式：**要么是在交易被确认之前，要么攻击者通过区块链分叉来撤销几个区块。**进行51%攻击的人，可以取消在旧链上的交易记录，然后在新分叉链上重新生成一个同样金额的交易，从而实现双重支付。

一条交易的确认数越多，越难被攻击者通过51%攻击篡改。对于大宗商品的交易，即使在付款24小时之后再发货，对买卖双方来说使用比特币支付也是方便并且有效率的。而24小时之后，这笔交易的全网确认数将达到至少144个（能有效降低被51%攻击的可能性）。

**共识攻击就像是针对下一个区块的拔河比赛**，强壮的组最可能赢。随着算力的降低，成功的可能性降低，因为其他矿工以“诚实”的挖矿能力控制着一些区块的产生。从另一个角度讲，一个攻击者拥有的算力越多，其故意创造的分叉区块链就可能越长，可能被篡改的最近的区块或者受其控制的未来的区块就会越多。一些安全研究组织利用统计模型得出的结论是，**算力达到全网的30%就足以发动51%攻击了**。

共识规则决定交易和区块的有效性。这些规则是所有比特币节点之间协作的基础，并负责将整个网络中所有不同角色的本地观点融合为一条一致的区块链。

**升级共识系统要困难得多，需要所有参与者之间的协调**。

硬分叉可用于改变共识规则，但需要在系统中所有参与者之间进行协调。没有升级到新的共识规则的任何节点都不能参与共识机制，并且被强制保留在硬分叉时刻单独的区块链上。因此，**硬分叉引入的变化可以被认为不是“向前兼容”**，因为未升级的系统不能再处理新的共识规则。

将硬分叉看成四个阶段：**软件分叉、网络分叉、挖矿分叉和区块链分叉。**

该过程开始于开发人员创建的客户端，这个客户端对共识规则进行了修改。

当这种新版本的客户端部署在网络中时，一定百分比的矿工、钱包用户和中间节点可以采用并运行该版本客户端。产生的分叉将取决于新的共识规则是否适用于区块、交易或系统其他方面。如果新的共识规则与交易有关，那么根据新规则创建交易的钱包可能会导致网络分叉，随后在交易被挖掘到区块中时发生硬分叉。如果新规则与区块有关，那么当一个区块根据新规则被挖掘时，硬分叉进程将开始。

首先是网络分叉。基于旧的共识规则的节点将拒绝根据新规则创建的任何交易和区块。此外，遵循旧的共识规则的节点将暂时禁止和断开与发送这些无效交易和区块的任何节点的联系。因此，网络将分为两部分：旧节点将只保留连接到旧节点，新节点只能连接到新节点。基于新规则的单个交易或区块将通过网络传播，结果是网络被分裂成了两个分区。

一旦使用新规则的矿工开采了一个块，挖矿能力和区块链也将分叉。新的矿工将在新区块之上挖掘，而老矿工将根据旧的规则挖掘一个单独的链条。分裂的网络使得按照各自共识规则运行的矿工不会接收彼此的块，因为它们连接到两个单独的网络。

软分叉 只有向前不兼容的共识规则的变化才会导致分叉。如果共识规则的改变也能够让未修改的客户端仍然按照先前的规则对待交易或者区块，那么就可以在不进行分叉的情况下实现共识修改。 **软分叉是对共识规则的向前兼容的升级，允许未升级的客户端程序继续在新的共识规则下工作。软分叉升级只能用于增加共识规则约束，而不能扩展它们。**

软分叉可以通过多种方式实现，所谓软分叉并不特指某种单一的方法，而是很多种方法，它们都有一个共同点：**它们不要求所有节点升级，或者强制非升级节点脱离共识。**

软分叉**重新定义NOP操作码 隔离见证**

由于软分叉允许未经修改的客户在共识内运作，软分叉的**“激活”**是基于矿工发出的准备信号：大多数矿工必须同意，准备并愿意执行新的共识规则。为了协调他们的行动，有一个信令机制，使他们能够表达对共识规则改变的支持。

共识规则分为两个步骤激活：

- 如果75％（最近1000个区块中的750个）标有版本“2”，则版本“2”的区块的创币交易中必须包含区块高度，否则这些区块会被拒绝导致无效。版本“1”的区块仍然被网络接受，不需要包含块高度，这个时期新旧共识规则共存。
- 当95％（最近1000区块中的950）是版本“2”时，版本“1”的区块不再被视为有效。版本“2”的区块只有当它们在coinbase字段中包含区块高度（根据先前阈值）时才有效。此后，所有区块必须符合新的共识规则，所有有效区块必须在创币交易中包含区块高度。

BIP-9将区块版本解释为位字段而不是整数。因为区块版本最初作为整数：版本1到4，因此只有29位可用作位字段。这样就留下了29位可用于独立和同时发出29个不同提案的准备就绪信号。

BIP-9还设置了**信令和激活的最大时间**。这样矿工们不需要永远发出信号。如果一个提案在超时期限内（这个值在提案中定义）未激活，则该提案视为被拒绝。该提案可以使用不同位的信令重新提交，更新激活周期。

一旦参数在比特币软件中已知（被定义），提案就以**定义（DEFINED）状态**开始。当区块的MTP大于等于开始时间（starttime）时，提案状态转换为**开始（STARTED）**。如果在难度调整周期内，投票数超过了阈值，并且尚未超时，则提案状态转换为**锁定**（LOCKED_IN）。一个难度调整周期后，提案变为**激活**（ACTIVE）。一旦达到该状态，提案会永久保持激活状态。如果超时后投票仍然没有超过阈值，那么提案状态更改为**失败**（FAILED），这表示提案被拒绝了。一个被**拒绝**（REJECTED）的提案会永久保持在这个状态。

## 比特币的安全

在比特币中，**所有权**是规则的全部。

比特币的核心原则是去中心化，这对安全性有重要的影响。

比特币则截然不同。一笔比特币交易仅仅授权一个特定的值到一个特定的接收方，并且不能够被伪造或者修改。它没有泄露任何像当事人身份的隐私信息，也不能被用于授权额外的支付。因此，一个比特币支付网络不需要被加密或者防止窃听。实际上，你可以通过开放的公共频道（像不安全的WiFi或者蓝牙）广播比特币交易，同时不会降低安全性。

在比特币中，共识系统创建了一个完全去中心化的受信的公共账本。一个正确被验证的区块链使用创世区块作为信任根，构建一个直到当前块的信任链条。比特币系统可以也应该使用区块链作为它们的信任根。当设计一个复杂的、包含多个运行在不同系统上的服务的区块链应用时，你应该仔细检查安全架构以确定信任的位置。最终唯一应该明确信任的是完全验证的区块链。如果你的应用显式地或者隐式地将信任赋予区块连之外的东西，那应该引起关注，因为这会引入漏洞。

**一个没有漏洞的比特币应用程序应该只会在比特币共识机制受损时出现漏洞，这意味着它的信任根位于比特币安全架构中最强大的部分。**

## 比特币应用

比特币系统被设计为一个分布式的货币及支付系统。

比特币区块链可以成为一个**提供可信服务的应用平台**（诸如智能合同等应用程序），远远超出了作为数字货币和支付的原始目的。

**杜绝双重支出**

比特币分布式共识算法的最基础的保证是确保UTXO不会被花费两次。

**不可篡改性**

一旦交易被记录在区块中，并且随后添加了足够多的区块，交易数据就变得不可篡改。不可篡改性是由算力进行保证的，因为重写区块链需要消耗很多算力才能产生工作量证明。所需的算力以及由此带来的不可变性的程度随着在包含交易的区块之后被提交的区块数量而增加。

**中立**

去中心化的比特币网络传播有效的交易，而不管这些交易的来源或内容如何。这意味着任何人都可以支付足够多的费用来创建有效的交易，并确信他们可以随时传输该交易并使其包含在区块链中。

**安全时间戳**

共识规则拒绝任何时间戳距离现在太远（过去和将来）的块。这可以确保块上的时间戳可以被信任。块上的时间戳意味着对所有交易包含的输入是未使用的保证。

**授权**

数字签名通过去中心化网络进行验证后，可提供授权担保。包含对数字签名要求的锁定脚本不能在未经脚本中隐含的私钥持有者授权的情况下执行。可审计性所有交易都是公开的，可以被审计。所有的交易和区块都以一个不间断的区块链链接到创世区块。

**交易原子性**

比特币交易是原子性的。它们要么是有效并且经过确认的（被打包挖矿过），要么不是。不存在确认交易的一部分，交易也不存在中间状态。在任何时间点，交易要么被打包挖矿，要么没有被打包挖矿

**染色币是指利用比特币交易来记录除比特币之外的外部资产以及外部资产的创建、所有权确认和转让的这类技术。所谓“外部资产”，是指这些资产不直接存储在比特币区块上，与比特币本身不同，因为比特币本身就区块链上的固有资产。**

染色币的最新实施**使用OP_RETURN脚本操作码将元数据存储在事务中**，并将存储的元数据与特定资产关联的外部数据结合使用。

**合约币（Counterparty）是在比特币之上建立的协议层**。与染色币类似的合约币协议提供了创建和交易虚拟资产与代币的能力。此外，合约币提供了去中心化的资产交换。合约币还实现了基于Ethereum虚拟机（EVM）的智能合约。

像染色币协议一样，合约币使用OP_RETURN操作码或1-N多重签名的公钥地址将元数据嵌入到比特币交易中。使用这些机制，合约币实现了基于比特币交易编码之上的协议层。

**支付通道是在比特币区块链之外双方之间交换的比特币交易的一种无须双方相互信任的机制**。如果这些交易在比特币区块链上结算，则是有效的，然而它们却是在链外被持有的，以期票的形式等待最终批量结算。由于交易不需要打包入链，因此它们可以在没有通常的结算等待的情况下进行交换，从而可以满足极高的交易吞吐量，以及低延迟（亚毫秒）和高精细粒度（satoshi级）。

**支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。**

通过一个交易在区块链上所锁定的共享状态，在交易两方之间建立了一个状态通道。这称为资金交易或锚点交易。这笔交易必须传送到网络并被挖矿确认以建立通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）

随后双方交换已签名的交易，这称为承诺交易

最后，可以通过合作方式关闭渠道，通过向区块链提交最终的结算交易，或者单方面提交最后的承诺交易到区块链。单方面能关闭通道选项是必要的，以防交易中的一方意外断开连接。结算交易代表通道的最终状态，并结算到区块链上。

在通道的整个生命周期中，**只有两个交易需要提交到区块链上进行挖矿：资金交易和结算交易**。在这两个状态之间，双方可以交换任何数量无须他人见证也无须提交到区块链上的承诺交易。

在通道生命中双方交换的每一项承诺交易都会被时间锁锁进未来的时间点。但是对于每个新产生的承诺交易，锁定时间会稍短一点，所以最新的承诺可以在它被前一承诺废止之前兑换。由于有了nLocktime，任何一方都只有等到时间锁到期后才能成功传播任何承诺交易。如果一切顺利，他们将合作并通过结算交易合理地关闭通道，这样一来发送中间的承诺交易就不必要了。实质上说，承诺交易只在一方断线而另一方不得不单方面关闭通道时才使用。

可撤销先前承诺交易的这种机制首先作为闪电网络的一部分被提出。

**闪电网络是一种端到端由双向支付通道连接的可路由网络。这样的网络可以允许任何参与者将支付从一通道发送到另一个通道，而不需要信任任何中间人**

**闪电网络是第二层路由技术。它可以应用于任何支持一些基本功能的区块链，如多重签名交易、时间锁和基本的智能合约。如果闪电网络搭建在比特币网络之上，则比特币网络在不牺牲无中介机构的无信任操作原则下，大幅提高交易容量、隐私性、粒度和速度。**

**无须信任运作闪电网络可以让对等节点在不需要互相信任的情况下使用比特币交易。因此，闪电网络保留了比特币系统的原理，同时显著扩大了其运行参数。**