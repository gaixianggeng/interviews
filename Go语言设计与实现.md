# 知识点整理

## 基础知识

### 数据结构

#### 数组

* 一块连续的内存
* 初始化之后大小无法改变
* 只有存储类型和大小完全相同才是同一类型
* 数组是否在堆中初始化在编译期间就确定了

#### 切片

```
Data 指向底层数组的指针
Len 当前切片的长度
Cap 切片容量，即Data数据的大小
```

* 切片的元素类型是在编译期间确定的
* 切片底层数组长度不足时，会触发扩容，切片指向的数组可能会发生变化
* 3种初始化切片的方式：通过数组下标、字面量、make
* 如果切片发生逃逸或者非常大，运行时会在堆中初始化切片
* a = append(a,b)后的切片会覆盖原切片,不需要担心切片发生复制而产生性能影响
* 扩容
  * 如果大于当前容量的两倍，使用期望容量
  * 当前切片容量小于1024，容量翻倍
  * 大于1024，每次增加25%，直到大约期望容量
  * 内存对齐
* 复制切片，注意对性能的影响

#### 哈希表

* 关键：哈希函数和冲突解决
* 哈希函数，保证尽可能均匀，然后通过工程手段解决哈希冲突问题
* 哈希冲突解决
  * 开放寻址法，每次查找时，都会检查当前位置是否已经被占用，如果没有被占用，则直接使用，如果被占用，则继续查找下一个位置
  * 拉链法 数组+链表，如果找到相同的键值对，更新对应的值，没有找到，在链表尾部追加
* 计算哈希、定位桶、遍历链表是主要开销
* 内部
  * buckets 桶数量 每个桶储存8个键值对
  * hash0 哈希种子
  * oldbuckets，在扩容时用于保存之前的桶字段，是当前buckets的一半
* 溢出桶 降低扩容频率
* 定位桶的是hash的低几位
* 每个桶存储对应hash的前8位
* 正常桶和溢出桶在内存中存储空间都是连续的
* 扩容不是原子过程
* 等量扩容和翻倍扩容 等量主要是为了解决出现较多溢出桶时整理内存，减少空间占用。
* 扩容期间会查询旧桶
* 写入会触发旧桶元素分流扩容，不会造成性能瞬时巨大抖动

#### 字符串

* 指向字节数组的指针和数组大小 底层一块连续的内存空间
* 只读 不支持直接修改string类型的内存空间
* 在拼接和转换时要注意性能损耗


### 语言特性

#### 函数调用
* 传值
* 通过栈传递函数的参数和返回值，所以可以有多个，c是寄存器，只能有一个泛返回值

#### 接口
* 隐式接口 鸭子类型
* iface表示带有方法的接口，eface表示interface{}
* interface{} 不是任意类型
* 使用结构体指针实现接口，使用结构体初始化无法通过编译
* 类型断言 通过比较itab.hash
* 动态派发在运行期间确定具体调用的函数 会带来额外的开销
